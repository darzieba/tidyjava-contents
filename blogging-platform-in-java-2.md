---
id: ghost-21
title: Project Setup - Blogging Platform #2
author: Grzegorz Ziemonski
summary: This week I'll continue the topic of creating a Blogging Platform. If you're not familiar with it, you can read the first part [here](http://tidyjava.com/blogging-platform-in-java-1/). I didn't have too much time to work on the project, but I got the very basic setup working, so we can look deeper into that.
date: 2016-07-14
tags:
    - java
    - blogging-platform
---
This week I'll continue the topic of creating a Blogging Platform. If you're not familiar with it, you can read the first part [here](http://tidyjava.com/blogging-platform-in-java-1/). I didn't have too much time to work on the project, but I got the very basic setup working, so we can look deeper into that.

### Vision Changes

I thought about the general vision a bit more and even discussed it with a friend, which lead me to two important changes in my short-term project vision:

1. I'm not going to avoid libraries and frameworks. Firstly, because these will seriously boost my productivity. Secondly, because I want to create something similar to the projects you can see in your work environment. Doing anything else would be selfish.
2. I think I won't need two elements, that I put in my initial design - "Content keeper" and "Content watch". The strive for simplicity suggests to start with something more straightforward and see how it works.

### Initializing the Project

As I'm pretty proficient with Spring Boot and Spring in general (maybe not the MVC part, but it can't be that hard :)), I decided to start the project using Spring Boot via [Spring Initializr](https://start.spring.io/).[^1]

After generating the project, the obvious first step was to create the `Application` class:

```java
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

I also added a `HomeController`, rendering a very basic view to make sure that Spring Boot and Freemarker are configured correctly:

```java
@Controller
public class HomeController {

    @RequestMapping("/")
    public String hello(Model model) {
        model.addAttribute("name", "World");
        return "home";
    }
}
```

This gives me something similar to the concept of a [walking skeleton](http://c2.com/cgi/wiki?WalkingSkeleton). That view is not an end-to-end function, but enough to say that things are working.

### Build Process

As I've written before, I'm using Gradle as the build tool. I'm *kind of* new to the tool, so any tips are welcome. Fortunately, I got the basic configuration generated by Spring Initializr.

For various tests, I'll be using Spock. Configuring that requires just adding the groovy plugin and some dependencies:

```groovy
apply plugin: 'groovy'
...
dependencies {
    ...
    // spock
    compile 'org.codehaus.groovy:groovy-all:2.4.1'
    testCompile 'org.spockframework:spock-core:1.0-groovy-2.4'
    testRuntime 'cglib:cglib-nodep:3.1'
    testRuntime 'org.objenesis:objenesis:2.1'
}
```

I created a simple test, to make sure that Gradle actually executes it:

```groovy
class HomeControllerSpec extends Specification {

    def "test"() {
        given:
        println("Test running again!")

        expect:
        true
    }
}
```

Last thing to do with the build was to set up [Travis CI](https://travis-ci.org/). Travis gives free CI to all open-source projects on GitHub and it's very easy to set up. All you have to do is create a `.travis.yml` file with contents similar to these:

```yaml
language: java
jdk:
- oraclejdk8

before_cache:
- rm -f  $HOME/.gradle/caches/modules-2/modules-2.lock
- rm -fr $HOME/.gradle/caches/*/plugin-resolution/
    cache:
      directories:
        - $HOME/.gradle/caches/
        - $HOME/.gradle/wrapper/
```

First 3 lines are obvious. The `before_cache` and `cache` parts are optional, but docs suggested to use them. CI from the very beginning, might not be absolutely necessary as long as I'm the only person working on the project, but it would be in any other case. Even in my case, it helps by proving that the build passes on other computers than mine.

### Cloud Deployment

Every project has to be deployed somewhere and this one is no exception. I chose [Heroku](heroku.com) as it has nice GitHub - Travis integration. I just add an app using my GitHub account, create a `Procfile` and I have Continous Delivery with a server for free. The `Procfile` looks like this:

```yaml
web: java $JAVA_OPTS  -Dserver.port=$PORT -jar build/libs/blogging-platform.jar
```

### Summary

I simplified the vision and decided to use frameworks and libraries freely. I generated a Gradle configuration with Spring Boot dependencies using Spring Initializr. To see that the configuration is correct, I created a simple controller with a view. Tests will be written in Spock, executed regularly by Travis CI. The application will be continously deployed to Heroku. You can see it working [here](http://blogging-platform.herokuapp.com/) (it might take a while to load, because it's on a free dyno).

[^1]: In one of the [previous posts](http://tidyjava.com/tidy-spring-starting-a-project/), I suggested not starting with the framework right away, but I don't think it makes any sense for a project that's basically merging file contents with view templates (at least for now).